syntax = "proto3";
package carcattonne_data;

message Coord {
	oneof coord_oneof {
		// snake_casing used here generates expected "coord1D" instead of "coord1d"
		Coord1D coord1_d = 1;
		Coord2D coord2_d = 2;
		Coord3D coord3_d = 3;
	}
}
	message Coord1D {
		int32 id = 1;
	}
	message Coord2D {
		int32 row = 1;
		int32 column = 2;
	}
	message Coord3D {
		int32 x = 1;
		int32 y = 2;
		int32 z = 3;
	}

message Node {
	Coord coord1 = 1;
	Coord coord2 = 2;
	Coord coord3 = 3;
}
message Edge {
	Coord coord1 = 1;
	Coord coord2 = 2;
}

message Hex {
	HexType type = 1;
	Coord coord = 2;
	ChitType chit = 3;
	// TODO: I saw implementations having multiple ports per hex. Make this repeated?
	PortType port = 4;
}
	enum HexType {
		NONEHEX = 0; // Used for boards that have fixed amount of hexagons
		RIVER = 1; // clay
		MOUNTAIN = 2; // ore
		PASTURE = 3; // sheep
		WHEATFIELD = 4; // wheatField instead of Field to have W as first letter
		FOREST = 5; // timber
		SEA = 6;
		DESERT = 7;
		HEXFROMBAG = 8; // the hex is picked from a bag
	}
	enum ChitType {
		ChitNone = 0; // the hex does not have a chit
		Chit2 = 1;
		Chit3 = 2;
		Chit4 = 3;
		Chit5 = 4;
		Chit6 = 5;
		Chit8 = 6;
		Chit9 = 7;
		Chit10 = 8;
		Chit11 = 9;
		Chit12 = 10;
		ChitFromBag = 11; // the chit is picked from a bag
	}
	enum PortType {
		Clay2To1 = 0;
		Ore2To1 = 1;
		Sheep2To1 = 2;
		Wheat2To1 = 3;
		Timber2To1 = 4;
		Any3To1 = 5; // 3 of same yields one gold
		Any4To1 = 6; // The default 4:1 trading ability
		FromBag = 7;
	}
enum ResourceType {
	Timber = 0;
	Wheat = 1;
	Ore = 2;
	Sheep = 3;
	Brick = 4;
	Gold = 5;
	Unknown = 6; // in opponents' list of resources to reduce spying
}
message BuildTown {
	Node node = 1;
}
message BuildRoad {
	Edge edge = 1;
}
message BuildCity {
	Node node = 1;
}
message BuyDevelopmentCard {
	DevelopmentCard development_card = 1;
}
message PlayDevelopmentCard {
	DevelopmentCard development_card = 1;
}
message TradeBank {
	repeated ResourceType offered_resources = 1;
	repeated ResourceType requested_resources = 2;
}
// a client requests to perform a game action
message GameActionRequest {
	int32 request_id = 1; // client-generated id to match response with request to update state
	oneof action {
		BuildTown build_town = 2;
		BuildRoad build_road = 3;
		BuildCity build_city = 4;
		BuyDevelopmentCard buy_development_card = 5;
		PlayDevelopmentCard play_development_card = 6;
		TradeBank trade_bank = 7;
	}
}
message GameAction {
	int32 id = 1;
	int32 game_id = 2;
	int32 player_id = 3;
	int32 user_id = 4;
	int32 turn_id = 5;
	int32 game_phase_id = 6;
	int32 turn_phase_id = 7;
	oneof action {
		BuildTown build_town = 8;
		BuildRoad build_road = 9;
		BuildCity build_city = 10;
		BuyDevelopmentCard buy_development_card = 11;
		PlayDevelopmentCard play_development_card = 12;
		TradeBank trade_bank = 13;
	}
}
message DevelopmentCard {
	int32 player_id = 1;
	int32 turn_bought_index = 2;
	int32 turn_played_index = 3;
	oneof development_card {
		VictoryPoint victory_point = 4;
		YearOfPlenty year_of_plenty = 5;
		Soldier soldier = 6;
		Monopoly monopoly = 7;
		RoadBuilding road_building = 8;
	}
}
message VictoryPoint { }
message YearOfPlenty {
	ResourceType resource_type1 = 1;
	ResourceType resource_type2 = 2;
}
message Soldier {
	Coord coord = 1;
}
message Monopoly {
	ResourceType resource_type = 1;
}
message RoadBuilding { }